<!doctype html><html lang=en><head><title>La Historia de la URL ::
Sysarmy — El blog de quienes dan soporte</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="La versión original de este post se puede encontrar en The Cloudflare Blog (inglés).
El 11 de enero de 1982 veintidós científicos de la computación se reunieron para discutir un problema con el “correo por computadora” (ahora conocido como email). Entre los presentes estaba el tipo que fundaría Sun Microsystems, el tipo que creó Zork, el tipo del NTP y el tipo que convenció al gobierno de pagar por Unix. El problema era simple: había 455 nodos en la ARPANET y la situación se estaba saliendo de control.
"><meta name=keywords content="history,historia,web,internet"><meta name=robots content="noodp"><link rel=canonical href=https://sysarmy.com/blog/posts/historia-de-la-url/><link rel=stylesheet href=https://sysarmy.com/blog/assets/style.css><link rel=stylesheet href=https://sysarmy.com/blog/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://sysarmy.com/blog/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://sysarmy.com/blog/img/favicon.png><link href=https://sysarmy.com/blog/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="La Historia de la URL"><meta name=twitter:description content="La historia de cómo evolucionó la URL"><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-MW9RRK2")</script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"b5c0b4816e829c93645aa7ad738aa3c0"})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4QJX7Y34Y"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4QJX7Y34Y")</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/blog class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>sysarmy:~ blog$</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://tienda.sysarmy.com/>Tienda</a></li><li><a href=https://www.youtube.com/channel/UCPE3EUzO58EBHzrJp2Fv7_A>Youtube</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://tienda.sysarmy.com/>Tienda</a></li><li><a href=https://www.youtube.com/channel/UCPE3EUzO58EBHzrJp2Fv7_A>Youtube</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>La Historia de la URL</h1><div class=post-meta><span class=post-date>November 8, 2022
</span><span class=post-read-time>— 33 minutos de lectura aprox.</span></div><span class=post-tags><a href=https://sysarmy.com/blog/tags/sysarmy/>#sysarmy</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/history/>#history</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/historia/>#historia</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/web/>#web</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/internet/>#internet</a>&nbsp;</span><figure class=post-cover><img src=https://sysarmy.com/blog/assets/historia-url-thumbnail.jpg alt="La Historia de la URL"></figure><div class=post-content><base href=https://sysarmy.com/blog/><p><em>La versión original de este post se puede encontrar en <a href=https://blog.cloudflare.com/the-history-of-the-url/>The Cloudflare Blog</a> (inglés).</em></p><p>El <a href=https://www.rfc-editor.org/rfc/rfc805.txt>11 de enero de 1982</a> veintidós científicos de la computación se reunieron para discutir un problema con el “correo por computadora” (ahora conocido como email). Entre los presentes estaba <a href=https://en.wikipedia.org/wiki/Bill_Joy>el tipo que fundaría Sun Microsystems</a>, <a href=https://en.wikipedia.org/wiki/Dave_Lebling>el tipo que creó Zork</a>, <a href=https://en.wikipedia.org/wiki/David_L._Mills>el tipo del NTP</a> y <a href=https://en.wikipedia.org/wiki/Bob_Fabry>el tipo que convenció al gobierno de pagar por Unix</a>. El problema era simple: había 455 nodos en la ARPANET y la situación se estaba saliendo de control.</p><p><img src=assets/historia-url-1.jpg alt></p><p>El problema se estaba gestando en ese momento porque la ARPANET estaba a punto de <a href=https://www.rfc-editor.org/rfc/rfc801.txt>migrar</a> de su protocolo original, el <a href=https://en.wikipedia.org/wiki/Network_Control_Program>NCP</a>, al protocolo TCP/IP el cual actualmente usa lo que llamamos Internet. Con ese cambio, de repente, habría una multitud de redes interconectadas (una ‘Inter… red’’, InterNet), lo que requería un sistema de dominios ‘jerárquico’ en el cual ARPANET podría resolver sus propios dominios mientras que el resto de las redes resolvían los suyos.</p><p>Otras redes de ese momento tenían grandes nombres como “COMSAT”, “CHAOSNET”, “UCLNET” y ÏNTELPOSTNET” y eran mantenidas por grupos de universidades y compañías de todo Estados Unidos que querían la posibilidad de poder comunicarse, podían afrontar el alquiler de líneas de 56k de las compañías de teléfono y comprar el requerido <a href=https://en.wikipedia.org/wiki/PDP-11>PDP-11s</a> para encargarse del ruteo.</p><p><img src=assets/historia-url-2.jpg alt></p><p>En el diseño original de ARPANET, un Centro de Información de Red (NIC) era responsable por el mantenimiento de un archivo que listaba todos los nodos de la red. El mismo era conocido como el archivo <a href=https://tools.ietf.org/html/rfc952><strong>HOSTS.TXT</strong></a>, similar al archivo <code>/etc/hosts</code> de un sistema Linux o OS X actual. Cada cambio en la red <a href=https://www.rfc-editor.org/rfc/rfc952.txt>requería</a> que el NIC lo transmitiera por FTP (un protocolo inventado en <a href=https://tools.ietf.org/html/rfc114>1971</a>) a todos los nodos de la red, una carga significativa para su infraestructura.</p><p>Tener un solo archivo que liste todos los nodos de Internet, obviamente, no escalaría indefinidamente. La prioridad era el email de todos modos, ya que era el desafío predominante a tratar ese día. Su conclusión final fue la de crear un sistema jerárquico en el cual podías consultar a un sistema externo por el dominio o conjunto de dominios que necesitabas. En sus palabras:</p><blockquote><p>“La conclusión en este área fue que el identificador de casilla de correo actual usuario@nodo debía ser extendido a ‘usuario@nodo.dominio’ donde ‘dominio’ podía ser una jerarquía de dominios.”
Y así nació el dominio.</p></blockquote><p><img src=assets/historia-url-3.gif alt></p><p>Es importante eliminar cualquier ilusión de que estas decisiones fueron tomadas a sabiendas del futuro que los dominios iban a tener. De hecho, la solución fue principalmente elegida porque era la que “ocasionaba menos dificultad para los sistemas existentes.” Por ejemplo, <a href=https://www.rfc-editor.org/rfc/rfc799.txt>una propuesta</a> pretendía que las direcciones de mail tuvieran la forma de <code>&lt;usuario>.&lt;nodo>@&lt;dominio></code>. Si los nombres de usuario de mail de esos días no hubieran ya tenido ‘.’ entre sus caracteres tal vez hoy estarías mandándome mails a ‘zack.cloudflare@com’.</p><p><img src=assets/historia-url-4.gif alt></p><h2 id=uucp-y-la-explosión-de-las-rutas>UUCP y la Explosión de las Rutas</h2><blockquote><p>Se ha dicho que la función principal de un sistema operativo es definir un número de diferentes nombres para el mismo objeto, para que se pueda ocupar de mantener el rastro de la relación entre todos los nombres diferentes. Los protocolos de red parecen tener de alguna manera la misma característica.</p><p>— David D. Clark, <a href=https://www.rfc-editor.org/rfc/rfc814.txt>1982</a></p></blockquote><p>Otra <a href=https://www.rfc-editor.org/ien/ien116.txt>propuesta fallida</a> proponía separar los componentes del dominio con el signo de exclamación (!). Por ejemplo, para conectarte con el nodo <code>ISIA</code> en <code>ARPANET</code>, te conectarías a <code>!ARPA!ISIA</code>. Podías entonces consultar por nodos usando comodines, así <code>!ARPA!*</code> te devolvería todos los nodos de <code>ARPANET</code>.</p><p>Este método de direccionamiento no era una divergencia loca del estándar, era un intento por mantenerlo. El sistema de nodos separados por signos de exclamación databa a una herramienta de transferencia de datos llamada <a href=http://www.cs.dartmouth.edu/~doug/reader.pdf>UUCP creada</a> en 1976. Si estás leyendo esto en una computadora con OS X o Linux, <code>uucp</code> probablemente esté instalado y disponible en la terminal.</p><p>ARPANET fue introducida en 1969, y rápidamente se convirtió en una herramienta de comunicación poderosa… entre un puñado de universidades e instituciones gubernamentales que tenían acceso a ella. La Internet como la conocemos no estaría disponible públicamente fuera de las instituciones de investigación hasta <a href=http://www.cybertelecom.org/notes/nsfnet.htm>1991</a>, veintiún años después. Pero eso no significaba que los usuarios de computadoras no se estuvieran comunicando entre sí.</p><p><img src=assets/historia-url-5.jpg alt></p><p>En la era anterior a la Internet, el método general de comunicación entre computadoras era con una conexión telefónica directa punto a punto. Por ejemplo, si querías mandarme un archivo, harías que tu módem llame a mi módem, y transferiríamos el archivo. Para convertir esto en un red, por así decirlo, nació UUCP.</p><p>En este sistema, cada computadora tiene un archivo que lista los nodos que conoce, sus números de teléfono y un usuario y contraseña en cada nodo. Entonces creas un ‘camino’, desde tu computadora actual a la de destino, a través de nodos, los cuales sólo sabían cómo conectarse al próximo salto:</p><p><code>sw-hosts!digital-lobby!zack</code></p><p><img src=assets/historia-url-6.jpg alt></p><p>Esta dirección no sólo serviría para enviarme archivos o conectarte con mi computadora directamente, también sería mi dirección de correo electrónico. En esta era anterior a los ‘servidores de correo’, si mi computadora estaba apagada no me podías mandar un email.</p><p>Mientras que el uso de ARPANET estaba restringido a universidades de primera, UUCP creó una Internet pirata para el resto de nosotros. Formó la base tanto para la <a href=https://en.wikipedia.org/wiki/Usenet>Usenet</a> como la <a href=https://en.wikipedia.org/wiki/Bulletin_board_system>BBS</a>.</p><h2 id=dns>DNS</h2><p>En definitiva, el sistema de DNS que todavía usamos actualmente sería <a href=https://www.rfc-editor.org/rfc/rfc882.txt>propuesto</a> en 1983. Si corres una consulta de DNS hoy, por ejemplo usando la herramienta <code>dig</code>, probablemente veas una respuesta que luce como esto:</p><pre><code>;; ANSWER SECTION:
google.com.   299 IN  A 172.217.4.206
</code></pre><p>Esto nos informa que google.com se encuentra en <code>172.217.4.206</code>. Como ya debes saber, la <code>A</code> nos informa que esto es un registro de dirección (‘address’), mapeando un dominio a una dirección IPv4. El <code>299</code> es el ‘tiempo de vida’, haciéndonos saber cuantos segundos de validez le quedan a este valor, antes de que requiera ser consultado nuevamente. ¿Pero qué significa el <code>IN</code>?</p><p><code>IN</code> significa ‘Internet’. Como mucho de esto, este campo se remonta a la era cuando había varias redes de computadoras distintas que necesitaban interoperar. Otros valores potenciales eran <code>CH</code> para <a href=https://en.wikipedia.org/wiki/Chaosnet>CHAOSNET</a> o <code>HS</code> para Hesiod que era el nombre para el servicio del <a href=https://en.wikipedia.org/wiki/Project_Athena>sistema Athena</a>. CHAOSNET murió hace mucho tiempo, pero una versión muy evolucionada de Athena todavía es utilizada por los estudiantes del MIT hasta hoy en día. Podés encontrar la lista de <a href=https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml>clases de DNS</a> en el sitio de IANA, pero no debería sorprenderte que solo uno de los valores posibles es de uso común hoy en día.</p><h2 id=tlds-top-level-domains>TLDs (Top Level Domains)</h2><blockquote><p>Es extremadamente poco probable que otro TLD vaya a ser creado.</p><p>— Jon Postel, <a href=https://tools.ietf.org/html/rfc1591>1994</a></p></blockquote><p>Una vez decidido que los nombres de dominio debían ser ordenados jerárquicamente, fue necesario decidir qué se ubicaba en la raíz de esa jerarquía. Esa raíz es tradicionalmente demostrada con un solo ‘.’. De hecho, terminar todos tus dominios con un ‘.’ es semánticamente correcto, y funciona con tu navegador de internet: <a href=https://google.com.>google.com.</a></p><p>El primer TLD fue <code>.arpa</code>. Permitía a los usuarios direccionar sus viejos y tradicionales nombres de equipo de ARPANET durante la transición. Por ejemplo, si mi máquina había sido registrada como <code>hfnet</code>, mi nueva dirección sería hfnet.arpa. Eso fue solo temporal, durante la transición, los administradores de servidores tenían una decisión muy importante que tomar: ¿cuál de de los cinco TLDs iban a usar? “.com”, “.gov”, “.org”, “.edu” o “.mil”.</p><p>Cuando decimos que el DNS es jerárquico, lo que queremos decir es que hay un grupo de servidores DNS raíz que son responsables, por ejemplo de convertir <code>.com</code> en servidores de nombre <code>.com</code>, que a su vez responderán cómo llegar a <code>google.com</code>. La zona DNS raíz de internet está compuesta por trece clusters (grupos) de servidores DNS. Hay solo <a href=https://www.internic.net/zones/named.cache>13 clusters de servidores</a>, porque eso es lo que entra en un único paquete UDP. Históricamente, DNS era operado a través de paquetes UDP, lo que significa que la respuesta a un pedido no puede superar nunca los 512 bytes.</p><pre><code>;       This file holds the information on root name servers needed to
;       initialize cache of Internet domain name servers
;       (e.g. reference this file in the &quot;cache  .  &quot;
;       configuration file of BIND domain name servers).
;
;       This file is made available by InterNIC 
;       under anonymous FTP as
;           file                /domain/named.cache
;           on server           FTP.INTERNIC.NET
;       -OR-                    RS.INTERNIC.NET
;
;       last update:    March 23, 2016
;       related version of root zone:   2016032301
;
; formerly NS.INTERNIC.NET
;
.                        3600000      NS    A.ROOT-SERVERS.NET.
A.ROOT-SERVERS.NET.      3600000      A     198.41.0.4
A.ROOT-SERVERS.NET.      3600000      AAAA  2001:503:ba3e::2:30
;
; FORMERLY NS1.ISI.EDU
;
.                        3600000      NS    B.ROOT-SERVERS.NET.
B.ROOT-SERVERS.NET.      3600000      A     192.228.79.201
B.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:84::b
;
; FORMERLY C.PSI.NET
;
.                        3600000      NS    C.ROOT-SERVERS.NET.
C.ROOT-SERVERS.NET.      3600000      A     192.33.4.12
C.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2::c
;
; FORMERLY TERP.UMD.EDU
;
.                        3600000      NS    D.ROOT-SERVERS.NET.
D.ROOT-SERVERS.NET.      3600000      A     199.7.91.13
D.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2d::d
;
; FORMERLY NS.NASA.GOV
;
.                        3600000      NS    E.ROOT-SERVERS.NET.
E.ROOT-SERVERS.NET.      3600000      A     192.203.230.10
;
; FORMERLY NS.ISC.ORG
;
.                        3600000      NS    F.ROOT-SERVERS.NET.
F.ROOT-SERVERS.NET.      3600000      A     192.5.5.241
F.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:2f::f
;
; FORMERLY NS.NIC.DDN.MIL
;
.                        3600000      NS    G.ROOT-SERVERS.NET.
G.ROOT-SERVERS.NET.      3600000      A     192.112.36.4
;
; FORMERLY AOS.ARL.ARMY.MIL
;
.                        3600000      NS    H.ROOT-SERVERS.NET.
H.ROOT-SERVERS.NET.      3600000      A     198.97.190.53
H.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:1::53
;
; FORMERLY NIC.NORDU.NET
;
.                        3600000      NS    I.ROOT-SERVERS.NET.
I.ROOT-SERVERS.NET.      3600000      A     192.36.148.17
I.ROOT-SERVERS.NET.      3600000      AAAA  2001:7fe::53
;
; OPERATED BY VERISIGN, INC.
;
.                        3600000      NS    J.ROOT-SERVERS.NET.
J.ROOT-SERVERS.NET.      3600000      A     192.58.128.30
J.ROOT-SERVERS.NET.      3600000      AAAA  2001:503:c27::2:30
;
; OPERATED BY RIPE NCC
;
.                        3600000      NS    K.ROOT-SERVERS.NET.
K.ROOT-SERVERS.NET.      3600000      A     193.0.14.129
K.ROOT-SERVERS.NET.      3600000      AAAA  2001:7fd::1
;
; OPERATED BY ICANN
;
.                        3600000      NS    L.ROOT-SERVERS.NET.
L.ROOT-SERVERS.NET.      3600000      A     199.7.83.42
L.ROOT-SERVERS.NET.      3600000      AAAA  2001:500:9f::42
;
; OPERATED BY WIDE
;
.                        3600000      NS    M.ROOT-SERVERS.NET.
M.ROOT-SERVERS.NET.      3600000      A     202.12.27.33
M.ROOT-SERVERS.NET.      3600000      AAAA  2001:dc3::35
; End of file
</code></pre><p>Los servidores DNS raíz operan en cajas fuertes, dentro de jaulas cerradas. Hay un reloj dentro de la caja fuerte para asegurar que el video de las cámaras no fue cambiado por un ciclo.
En particular, teniendo en cuenta lo lenta que ha sido la implementación de <a href=https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions>DNSSEC</a>, un ataque a uno de estos servidores podría permitir a un atacante redirigir todo el tráfico de Internet para una porción de los usuarios de Internet. Esto, por supuesto, sería la película de atracos más fantástica que se pueda hacer.</p><p>No debería sorprender a nadie que los servidores de nombre de los TLD raíz no cambian muy frecuentemente. <a href=http://dns.measurement-factory.com/writings/wessels-pam2003-paper.pdf>98%</a> de las consultas que reciben los DNS raíz son por error, generalmente por clientes rotos o mal configurados que no almacenan bien sus resultados. Esto se convirtió en un problema tal que muchos operadores de DNS raíz tuvieron que <a href=https://www.as112.net/>instanciar</a> servidores especiales simplemente para responderles “salí de acá” a toda la gente que hacía consultas de DNS reverso por sus direcciones IP locales.</p><p>Los servidores de nombre TLD son administrados por diferentes compañías y gobiernos alrededor del mundo (<a href=https://www.verisign.com/>Verisign</a> administra <code>.com</code>). Cuando compras un dominio <code>.com</code>, alrededor de US $0.18 va la ICANN y US $7.85 va a Verisign.</p><h2 id=punycode-código-insignificante>Punycode (Código insignificante)</h2><p>Es raro en este mundo que los nombres tontos que nosotros los desarrolladores pensamos para un nuevo proyecto llegue al producto final y público. Podemos nombrar la base de datos de la compañía Delaware (porque ahí es donde todas las compañías son registradas), pero podés estar seguro de que para el momento en que llega a producción se llamará AlmacenamientoMetadataCompañía. Pero raramente, cuando todas las estrellas se alinean y el jefe está de vacaciones, alguna se escapa por las rajaduras.</p><p>Punycode es el sistema que usamos para codificar unicode en nombres de dominio. El problema que soluciona es simple, ¿cómo escribir 比薩.com cuando todo el sistema de Internet fue desarrollado usando el alfabeto <a href=https://en.wikipedia.org/wiki/ASCII>ASCII</a> cuyo carácter más foráneo es el tilde?</p><p>No es tan simple como cambiar los dominios para usar <a href=https://en.wikipedia.org/wiki/Unicode>unicode</a>. Los <a href=https://tools.ietf.org/html/rfc1035>documentos originales</a> que gobiernan los dominios especifican que deben ser codificados en ASCII. Todo equipamiento de hardware de internet de los últimos cuarenta años, incluyendo los router <a href=https://www.cisco.com/c/en/us/support/routers/crs-1-multishelf-system/model.html>Cisco</a> y <a href=https://www.juniper.net/techpubs/en_US/release-independent/junos/information-products/pathway-pages/t-series/t1600/>Juniper</a> usados para entregar esta página hacen esta suposición.</p><p>La web en sí <a href=http://1997.webhistory.org/www.lists/www-talk.1994q3/1085.html>nunca fue solo ASCII</a>. Fue originalmente concebida para hablar <a href=https://en.wikipedia.org/wiki/ISO/IEC_8859-1>ISO 8859-1</a> que incluye todos los caracteres ASCII, pero suma un grupo de caracteres especiales como ¼ y letras con marcas especiales como ä. Sin embargo, no contiene letras no latinas.</p><p>Esta restricción en el HTML fue eliminada en <a href=https://tools.ietf.org/html/rfc2070>2007</a> y ese mismo año Unicode se <a href=https://googleblog.blogspot.com/2008/05/moving-to-unicode-51.html>convirtió</a> en el conjunto de caracteres más popular de la web. Pero los dominios todavía están confinados al ASCII.</p><p><img src=assets/historia-url-7.gif alt></p><p>Como podrás adivinar, Punycode no fue la primera propuesta para solucionar este problema. Seguramente escuchaste hablar de UTF-8, que es una forma popular de codificar Unicode en bytes (el 8 es por los ocho bits en un byte). En el año <a href=https://tools.ietf.org/html/draft-jseng-utf5-01>2000</a> varios miembros del IETF (Grupo de Tareas de Ingenieros de Internet) desarrollaron el UTF-5. La idea era codificar Unicode en trozos de 5 bits. Podías entonces mapear cada grupo de 5 bits con uno de los caracteres permitidos (A-V & 0-9) en los nombres de dominio. Así que si yo tenía un sitio para aprender el idioma japonés, mi sitio 日本語.com se convertía en el críptico M5E5M72COA9E.com.</p><p>Este método de codificación tenía bastantes desventajas. La primera, A-V y 0-9 eran usados como salida de la codificación, lo que significaba que si querías incluir uno de esos caracteres en tu dominio, tenía que ser codificado como todo lo demás. Esto generaba dominios muy largos, lo que es un problema serio cuando cada segmento de un dominio está limitado a 63 caracteres. Un dominio en el idioma de Myanmar estaría limitado a no más de 15 caracteres. Sin embargo, la propuesta realiza una sugerencia interesante para usar UTF-5 para permitir transmitir Unicode a través de código Morse o telegrama.</p><p>También estaba la cuestión de cómo hacerle saber al cliente que este dominio estaba codificado así podían mostrarlo con los caracteres Unicode apropiados en lugar de mostrar M5E5M72COA9E.com en mi barra de direcciones. Hubo <a href=https://tools.ietf.org/html/draft-ietf-idn-compare-01>varias sugerencias</a>, una de las cuales fue usar el bit que no se usaba de la respuesta de DNS. Era el “último bit no utilizado de la cabecera”, y la gente de DNS se “resistía mucho a entregarlo” sin embargo.</p><p>Otra idea fue empezar cada dominio usando este método de codificación con <code>ra–</code>. Hasta <a href=https://tools.ietf.org/html/draft-ietf-idn-race-00>ese momento</a> (mediados de abril del 2000), no había dominios que empezaran con esos caracteres particulares. Si se algo sobre Internet, alguien registró el dominio <code>ra–</code> solo para molestar inmediatamente después de que se publicó la propuesta.</p><p>La <a href=https://tools.ietf.org/html/rfc3492>conclusión final</a>, se alcanzó en 2003, fue adoptar un formato llamado Punycode que incluía una forma de compresión delta que podría acortar dramáticamente nombres de dominio codificados. La compresión delta es una idea particularmente buena porque probabilísticamente todos los caracteres de tu dominio se encuentran en el mismo área general dentro de Unicode. Por ejemplo, dos caracteres en farsi van a estar mucho más cerca que un carácter en farsi y otro en hindi. Para dar un ejemplo de cómo funciona, si tomamos la frase sin sentido:</p><p>يذؽ</p><p>En un formato no comprimido, eso sería almacenado como tres caracteres: <code>[1620, 1584, 1597]</code> (basado en sus códigos Unicode). Para comprimir esto primero tenemos que ordenarlos numéricamente (registrando dónde estaban esos caracteres originalmente): <code>[1584, 1597, 1620]</code>. Luego podemos guardar el valor menor (<code>1584</code>), y el delta (diferencia) entre ese valor y el próximo carácter (<code>13</code>), y luego nuevamente para el próximo carácter (<code>23</code>), que es significativamente menos para transmitir y almacenar.</p><p>Punycode entonces codifica (muy) eficientemente esos enteros en caracteres permitidos en nombres de dominio, e inserta <code>xn–</code> al principio para informar a los consumidores que este es un dominio codificado. Notarás que todos los caracteres Unicode se ubican juntos al final del dominio. No solo codifican su valor, también codifican dónde deberían ser insertados dentro de la porción ASCII del dominio. Para poner un ejemplo, el sitio 熱狗sales.com se convierte en <code>xn–sales-r651m0e.com</code>. Cada vez que tipeás un nombre de dominio basado en Unicode en la barra de direcciones de tu navegador, es codificado de esta manera.</p><p>Esta transformación podría ser transparente, pero introduce un problema de seguridad importante. Toda clase de caracteres Unicode se imprimen como caracteres ASCII existentes. Por ejemplo, posiblemente no puedas ver la diferencia entre la letra a (“а”) minúscula cirílica y la letra a (“a”) latina. Si registro amazon.com en cirílico (xn-mazon-3ve.com), y me las arreglo para que lo visites, va a ser difícil para vos darte cuenta que estas en el sitio equivocado. Por esa razón, cuando visitás <a href=http://xn--vi8hiv.ws/>🍕💩.ws</a>, tu navegador muestra la versión aburrida <code>xn–vi8hiv.ws</code> en la barra de direcciones.</p><h2 id=protocolo>Protocolo</h2><p>La primera parte del URL es el protocolo que debería usarse para accederlo. El protocolo más común es el <code>http</code>, que es el simple protocolo de transferencia de documentos inventado por Tim Berners-Lee específicamente para la web. No era la única opción. <a href=http://1997.webhistory.org/www.lists/www-talk.1993q2/0339.html>Algunas personas</a> creen que simplemente deberíamos haber usado Gopher. En lugar de ser de propósito general, Gopher está específicamente diseñado para enviar datos estructurados de manera similar a un árbol de archivos.</p><p>Por ejemplo si pedís el montaje <code>/Cars</code>, te podría devolver:</p><pre><code>1Chevy Camaro             /Archives/cars/cc     gopher.cars.com     70
iThe Camaro is a classic  fake                  (NULL)              0
iAmerican Muscle car      fake                  (NULL)              0
1Ferrari 451              /Factbook/ferrari/451  gopher.ferrari.net 70
</code></pre><p>que identifica dos autos, junto con metadatos sobre ellos y dónde te podés conectar para más información. La idea era que tu cliente le daría procesada esta información de alguna manera en la que enlazaría las entradas con las páginas de destino.</p><p><img src=assets/historia-url-8.gif alt></p><p>El primer protocolo popular fue el FTP, que fue creado en 1971, como una manera de listar y descargar archivos de computadoras remotas. Gopher era una extensión lógica de esto, que proveía un listado similar, pero incluía facilidades para leer también los metadatos de las entradas. Esto significaba que podía ser usado con propósitos más liberales como noticias o una simple base de datos. No tenía, sin embargo, la libertad y simplicidad que caracteriza al HTTP y el HTML.</p><p>HTTP es un protocolo muy simple, particularmente comparado con alternativas como el FTP o incluso el protocolo <a href=https://blog.cloudflare.com/http3-the-past-present-and-future/>HTTP/3</a>, que está aumentando en popularidad actualmente. Primero, el HTTP está completamente basado en texto, en lugar de estar compuesto por conjuros binarios a medida (que lo habrían hecho significativamente más eficiente). Tim Berners-Lee intuyó correctamente que usar un formato basado en texto haría más fácil el desarrollo y la solución de problemas en aplicaciones basadas en HTTP para generaciones de programadores.</p><p>El HTTP tampoco hace casi ninguna suposición respecto de lo que estás transmitiendo. A pesar de que fue inventado explícitamente para acompañar el lenguaje HTML, te permite especificar que tu contenido es de cualquier tipo (usando el MIME <code>Content-Type</code>, que era una nueva invención en ese momento). El protocolo en sí es bastante simple.</p><p>Una consulta así:</p><pre><code>GET /index.html HTTP/1.1
Host: www.example.com
</code></pre><p>Respondería:</p><pre><code>HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Encoding: UTF-8
Content-Length: 138
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: &quot;3f80f-1b6-3e1cb03b&quot;
Accept-Ranges: bytes
Connection: close

&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;An Example Page&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		Hello World, this is a very simple HTML document.
	&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Para poner esto en contexto, podes pensar que el sistema de redes que usa Internet empezando por el Protocolo Internet, el IP. El IP es responsable de llevar un pequeño paquete de datos (alrededor de 1500 bytes) de una computadora a otra. Arriba de eso tenemos el TCP, que es responsable de llevar bloques más grandes de datos como documentos enteros y archivos, enviándolos mediante muchos paquetes IP de manera confiable. Por encima de eso, implementamos un protocolo como el HTTP o el FTP, que especifica qué formato se debería usar para hacer que esos datos que enviamos vía TCP (o UDP, etc) sean entendibles y tengan sentido.</p><p>En otras palabras, el TCP/IP manda un conjunto de bytes a otra computadora, el protocolo dice qué son esos datos y qué significan.</p><p>Podes armar tu propio protocolo si querés, acomodar los bytes en tus mensajes TCP como quieras. El único requerimiento es que quien sea con quien estés hablando tiene que hacerlo en el mismo idioma. Por esta razón es común estandarizar estos protocolos.</p><p>Hay, por supuesto, protocolos menos importantes para jugar. Por ejemplo el protocolo <a href=https://www.rfc-editor.org/rfc/rfc865.txt>“Cita del día”</a> (puerto 17), y el protocolo de <a href=https://www.rfc-editor.org/rfc/rfc864.txt>Caracteres Aleatorios</a> (puerto 19). Parecen tontos hoy, pero también muestran cuán importante era un protocolo general de transmisión de documentos como el HTTP.</p><h2 id=puerto>Puerto</h2><p>El lugar en la historia de Gopher y HTTP puede ser evidenciado por sus puertos por defecto. Gopher es el 70, HTTP el 80. El puerto HTTP fue asignado (probablemente por <a href=https://en.wikipedia.org/wiki/Jon_Postel>Jon Postel</a> en la IANA) a pedido de Tim Berners-Lee en algún momento entre <a href=https://tools.ietf.org/html/rfc1060>1990</a> y <a href=https://tools.ietf.org/html/rfc1340>1992</a>.</p><p>Este concepto de registrar ‘números de puerto’ predata incluso a Internet. El protocolo original NCP que usaban ARPANET las direcciones remotas eran identificadas por 40 bits. Los primeros 32 identificaban al nodo remoto, de manera similar a cómo funciona una dirección IP hoy en día. Los últimos 8 eran conocidos como los <a href=https://tools.ietf.org/html/rfc433>AEN</a> (significaba “Otros Ocho Dígitos” por su sigla en inglés), y eran utilizados por la máquina remota de la manera que nosotros usamos un número de puerto, para separar mensajes destinados a diferentes procesos. En otras palabras, la dirección especifica a qué máquina debería ir el mensaje, y el AEN (o número de puerto) le dice a la máquina remota qué aplicación debe recibirlo.</p><p>Rápidamente <a href=https://tools.ietf.org/html/rfc322>pidieron</a> que los usuarios registren estos ‘números de socket’ para limitar posibles colisiones. Cuando los números de puerto fueron expandidos a 16 bits por TCP/IP, el proceso de registración continuó.</p><p>Mientras que los protocolos tienen un puerto por defecto, tiene sentido permitir que se especifique un puerto manualmente para permitir desarrollos locales y la posibilidad de correr múltiples servicios en la misma máquina. Esa misma lógica fue la <a href=http://1997.webhistory.org/www.lists/www-talk.1992/0335.html>base</a> para los prefijos de los sitios <code>www.</code>. En ese momento, era poco probable que alguien estuviera accediendo a la raíz del dominio, simplemente por correr un sitio web experimental. Pero si le das a los usuarios el nombre de nodo de tu máquina específica (<code>dx3.cern.ch</code>) estarías en problemas cuando necesites reemplazar esa máquina. Al usar un subdominio común (<code>www.cern.ch</code>) podes cambiar a qué apunta según lo requieras.</p><h2 id=el-pedacito-del-medio>El pedacito del medio</h2><p>Como probablemente sabés, la sintaxis del URL pone una doble barra (<code>//</code>) entre el protocolo y el resto de la URL:</p><p><code>http://cloudflare.com</code></p><p>Esa doble barra fue heredada del sistema <a href=https://en.wikipedia.org/wiki/Apollo/Domain>Apollo</a> que fue una de primeras estaciones de trabajo en red. El equipo de Apollo tenía un problema similar al de Tim Berners-Lee: necesitaban una forma de separar una ruta de la máquina en la que esa ruta se encuentra. Su solución fue crear un formato especial de ruta:</p><p><code>//nombredeequipo/archivo/ruta/</code></p><p>Y TBL copió ese formato. Por cierto, él ahora se <a href=https://www.w3.org/People/Berners-Lee/FAQ.html#etc>arrepiente</a> de esa decisión, deseando que el dominio (en este caso <code>ejemplo.com</code>) fuera la primera parte de la ruta:</p><p><code>http:com/ejemplo/foo/bar/baz</code></p><blockquote><p>Las URLs nunca fueron pensadas para lo que se han convertido: una manera arcaica para que un usuario identifique un sitio en la Web. Desafortunadamente, nunca hemos podido estandarizar los URNs, que nos darían un sistema de nombres más útil. Decir que el sistema actual de URL es suficiente es como alabar la línea de comandos de DOS, y decir que la mayoría de la gente simplemente debería aprender la sintaxis de la línea de comandos. La razón por la cual tenemos un sistema de ventanas es para hacer las computadoras más fáciles de usar, y extender su uso. La misma línea de pensamiento debería llevarnos a una mejor forma de localizar sitios específicos en la web.</p><p>— Dougherty, <a href=https://lists.w3.org/Archives/Public/www-talk/1996JanFeb/0075.html>1996</a></p></blockquote><p>Hay muchas formas diferentes de entender la ‘Internet’. Una es como un sistema de computadoras conectadas usando una red de computadoras. Esa versión de Internet nació en 1969 con la creación de ARPANET. Correo, archivos y chat, todo se movía sobre esa red antes de la creación del HTTP, el HTML, o el ‘navegador web’.</p><p>En 1992 Tim Berners-Lee creó tres cosas, dando a luz a los que <em>nosotros</em> consideramos Internet. El protocolo HTTP, el HTML y la URL. Su objetivo era traer a la vida el ‘Hipertexto’. El Hipertexto en su forma más simple es la habilidad de crear documentos que se enlazan entre sí. En ese momento era visto como una panacea de la ciencia ficción, para ser suplementado con la <a href=https://en.wikipedia.org/wiki/Hypermedia>Hipermedia</a>, y cualquier otra palabra a la que le pudieras agregar ‘Hiper’.</p><p>El requerimiento principal del Hipertexto era la habilidad de enlazar desde un documento a otro. En tiempos de TBL, sin embargo, estos documentos eran alojados en una multitud de formatos y accedidos a través de protocolos como <a href=https://en.wikipedia.org/wiki/Gopher_%28protocol%29>Gopher</a> o FTP. Necesitaba una forma consistente de referenciar a un archivo que codificara su protocolo, su nodo en la Internet, y dónde existía en ese nodo.</p><p>En la <a href=https://www.w3.org/Conferences/IETF92/WWX_BOF_mins.html>presentación original</a> de la World-Wide Web en marzo de 1992 TBL lo describió como un ‘Identificador de Documento Universal’ (UDI, por su sigla en inglés). Muchos <a href=https://www.w3.org/Protocols/old/osi-ds-29-00.txt>formatos diferentes</a> fueron considerados para este identificador:</p><pre><code>protocol: aftp host: xxx.yyy.edu path: /pub/doc/README

PR=aftp; H=xx.yy.edu; PA=/pub/doc/README;

PR:aftp/xx.yy.edu/pub/doc/README

/aftp/xx.yy.edu/pub/doc/README
</code></pre><p>Este documento también explica por qué los espacios deben ser codificados en las URLs (%20):</p><blockquote><p>El uso de caracteres de espacios en blanco ha sido evitado en los UDIs: los espacios
no son caracteres legales. Esto fue hecho así por la frecuente
introducción de caracteres de espacio blanco extraños cuando las líneas son terminadas
por sistemas como el mail, o la necesidad de columnas estrechas, y
por la inter-conversión entre varias formas de espacios en blanco
que ocurre durante la conversión de código de caracteres y la transferencia
de texto entre aplicaciones.</p></blockquote><p>Lo que es más importante entender, es que la URL era fundamentalmente una forma abreviada de referirse a la combinación de esquema, dominio, puerto, credenciales y una ruta que previamente tenía que ser entendida contextualmente para cada sistema de comunicación diferente.
Fue oficialmente definida por primera vez en un <a href=https://www.ietf.org/rfc/rfc1738.txt>RFC</a> publicado en 1994.</p><p><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></p><p>Este sistema permitió referenciar diferentes sistemas desde dentro del Hipertexto, pero ahora que casi todo el contenido está publicado sobre HTTP, tal vez ya no sea necesario. Ya en <a href=https://lists.w3.org/Archives/Public/www-talk/1996JanFeb/0075.html>1996</a> los navegadores estaban agregando <code>http://</code> y <code>www.</code> a sus usuarios automaticamente (convirtiendo cualquier anuncio que todavía los tenga en algo realmente ridículo).</p><h2 id=ruta>Ruta</h2><blockquote><p>No creo que la pregunta sea sobre si las personas pueden aprender el significado del URL, simplemente me parece moralmente despreciable forzar a la abuela o al abuelo a entender lo que, en definitiva, son convenciones del sistema de archivos de UNIX.</p><p>— Israel del Rio, <a href=https://lists.w3.org/Archives/Public/www-talk/1996JanFeb/0041.html>1996</a></p></blockquote><p>El componente separado por barras de la URL debería ser familiar para cualquier usuario de cualquier computadora construida en los últimos cincuenta años. El sistema de archivos jerárquico en sí fue introducido por el sistema <a href=http://www.multicians.org/>MULTICS</a>. Su creador a su vez, lo atribuye a <a href=http://www.csl.sri.com/users/neumann/>una conversación de dos horas que tuvo con Albert Einstein</a> en 1952.</p><p>MULTICS usaba el símbolo “mayor que” (>) para separar los componentes de la ruta de archivos. Por ejemplo:</p><p><code>\>usr\>bin\>local\>awk</code></p><p>Esto era perfectamente lógico, pero desgraciadamente la gente de Unix <a href=https://www.bell-labs.comusr/dmr/www/cacm.html>decidió</a> usar &lsquo;>&rsquo; para representar la redirección, delegando la separación de la ruta a la barra hacia adelante (&rsquo;/&rsquo;, barra de dividir).</p><h2 id=snapchateá-a-la-corte-suprema>Snapchateá a la Corte Suprema</h2><blockquote><p>Estás equivocado. Estamos, ahora lo veo claramente, * en desacuerdo *. Vos y yo.</p><p>&mldr;</p><p>Como persona me reservo el derecho de usar diferentes criterios para diferentes propósitos. Quiero poder darle nombres a trabajos genéricos, Y a traducciones particulares Y a versiones particulares. Quiero un mundo más rico que el que vos proponés. No quiero ser limitado por tu sistema de dos niveles de “documentos” y “variantes”.</p><p>— Tim Berners-Lee, <a href=http://1997.webhistory.org/www.lists/www-talk.1993q3/1003.html>1993</a></p></blockquote><p><a href="https://journals.cambridge.org/action/displayAbstract?fromPage=online&amp;aid=9282809&amp;fileId=S1472669614000255">La mitad</a> de las URLs referenciadas por opiniones de la Corte Suprema de los Estados Unidos apuntan a páginas que ya no existen. Si leiste un paper académico en 2011, escrito en 2001, tuviste muchas posibilidades de que las URL no fueran <a href=https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-S14-S5>válidas</a>.</p><p>Había una <a href=http://1997.webhistory.org/www.lists/www-talk.1993q2/0234.html>ferviente creencia</a> en 1993 de que las URL morirían en favor del ‘URN’. El Uniform Resource Name (Recurso de Nombre Uniforme) es una referencia permanente a una pieza de contenido dado que, a diferencia de la URL, no cambiará jamás o se romperá. Tim Berners-Lee describió inicialmente la “necesidad urgente” de ellos hacia <a href=http://1997.webhistory.org/www.lists/www-talk.1991/0018.html>1991</a>.</p><p>La forma más simple para crear un URN puede ser simplemente usar un hash criptográfico del contenido de la página, por ejemplo: <code>urn:791f0de3cfffc6ec7a0aacda2b147839</code>. Sin embargo, este método no cumple con el criterio de la comunidad web, ya que no había posibilidad de darse cuenta de a quién pedirle que convierta ese hash en una pieza de contenido real. Tampoco tenía en cuenta cambios de formato que muchas veces le ocurren a los archivos (comprimido vs descomprimido por ejemplo) que sin embargo representan el mismo contenido.</p><p><img src=assets/historia-url-9.jpg alt></p><p>En 1996 Keith Shafer y otros propusieron una solución al problema de las URL rotas. <a href=https://purl.oclc.org/docs/inet96.html>El link</a> está roto. Roy Fielding publicó una sugerencia de implementación en julio de 1995. <a href=http://ftp.ics.uci.edu/pub/ietf/uri/draft-ietf-uri-roy-urn-urc-00.txt>Ese link</a> está roto.</p><p>Pude encontrar estas páginas a través de Google, que funcionalmente ha convertido los títulos de las páginas en los URN de hoy. El formato URN fue finalizado en 1997, y esencialmente no se ha usado nunca desde entonces. La implementación en sí es interesante. La URN está compuesta por dos partes, una <code>autoridad</code> que puede resolver cierto tipo de URN, y el ID específico de ese documento en el formato que entiende la <code>autoridad</code>. Por ejemplo, <code>urn:isbn:0131103628</code> identificará un libro, formando un link permanente que puede (con suerte) ser convertido en un conjunto de URLs por tu resolvedor local <code>isbn</code>.</p><p>Dado el poder de los motores de búsqueda hoy en día, posiblemente, el mejor formato de URN podría ser una simple manera de que los archivos apunten a sus antiguas URLs. Lo que permitiría a los buscadores indexar esta información y vincularnos apropiadamente:</p><pre><code>&lt;!-- On http://zack.is/history →
&lt;link rel=&quot;past-url&quot; href=&quot;http://zackbloom.com/history.html&quot;&gt;
&lt;link rel=&quot;past-url&quot; href=&quot;http://zack.is/history.html&quot;&gt;
</code></pre><h2 id=parámetros-de-consulta>Parámetros de consulta</h2><blockquote><p>El formato &ldquo;application/x-www-form-urlencoded&rdquo; es de muchas maneras una monstruosidad aberrante, el resultado de muchos años de accidentes de implementación y adaptaciones que llevaron a un conjunto de requerimientos necesarios para la interoperabilidad, pero que de ninguna manera representa las buenas prácticas del diseño.</p><p>— <a href=https://url.spec.whatwg.org/#application/x-www-form-urlencoded>WhatWG URL Spec</a></p></blockquote><p>Si has usado la web por algún tiempo, estás familiarizado con los parámetros de consulta. Le siguen a la porción de ruta de la URL, y codifican opciones como <code>?nombre=nachi&amp;estado=caba</code>. Tal vez te resulte extraño que las consultas usen el carácter et (ampersand ‘&’) que es el mismo carácter usado en HTML para codificar (escapar) caracteres especiales. De hecho, si has usado HTML por un tiempo, seguramente has tenido que codificar ‘ets’ en URLs, convirtiendo <code>http://nodo/?x=1&amp;y=2</code> en <code>http://nodo?x=1&amp;#38;y=2</code> (esa confusión en particular siempre <a href=http://1997.webhistory.org/www.lists/www-talk.1992/0447.html>ha existido</a>).</p><p>Tal vez también hayas notado que las cookies siguen un formato similar, pero distinto: <code>x=1,y=2</code> que no conflictúa con la codificación de caracteres del HTML. La W3C no se olvidó de esta idea, animó a los implementadores para que soporten <code>;</code> a la vez que <code>&</code> en parámetros de consultas desde 1995.</p><p>Originalmente, esta sección de la URL era estrictamente usada para buscar ‘índices’. La Web fue creada originalmente para (y su financiación asignada para) crear un método de colaboración para físicos de altas energías. Esto no quiere decir que Tim Berners-Lee no sabía que lo que realmente estaba creando era una herramienta de comunicación de uso general. No <a href=http://1997.webhistory.org/www.lists/www-talk.1993q1/0286.html>agregó soporte</a> para tablas hasta muchos años después, algo que los físicos habrían necesitado.</p><p>De cualquier manera, estos ‘físicos’ necesitaban una forma de codificar y vincular información, y una forma de buscar esa información. Para proveer eso, Tim Berners-Lee creó la etiqueta <code>&lt;ISINDEX></code>. Si <code>&lt;ISINDEX></code> aparecía en una página, informaba al navegador que esa era una página en la que se podía buscar. El navegador debería mostrar un campo de búsqueda, y permitir al usuario enviar una consulta al servidor.</p><p>Esa consulta estaba formateada como palabras claves separadas por un carácter de suma (+):</p><p><code>http://cernvm/FIND/?sgml+cms</code></p><p>Como todo en Internet, esta etiqueta fue abusada de todas las maneras posibles, incluyendo la posibilidad de proveer un campo de entrada para calcular raíces cuadradas. Rápidamente <a href=https://lists.w3.org/Archives/Public/www-talk/1992NovDec/0042.html>se propuso</a> que tal vez esto era muy específico y que realmente se necesitaba una etiqueta general de <code>&lt;input></code> (entrada).</p><p>Esa propuesta en particular usa signos de suma para separar los componentes de lo que de cualquier manera se ve como una consulta GET moderna:</p><p><code>http://algunnodo.lugar/alguna/ruta?x=xxxx+y=yyyy+z=zzzz</code></p><p>Esto estuvo lejos de ser aclamado universalmente. <a href=https://lists.w3.org/Archives/Public/www-talk/1992NovDec/0032.html>Algunos creían</a> que necesitábamos una manera de decir que el contenido del otro lado del vínculo podía ser buscable:</p><p><code>&lt;a HREF="wais://quake.think.com/INFO" INDEX=1>search&lt;/a></code></p><p>Tim Berners-Lee <a href=https://lists.w3.org/Archives/Public/www-talk/1992NovDec/0044.html>pensó</a> que debíamos tener una manera de definir consultas fuertemente tipadas:</p><p><code>&lt;ISINDEX TYPE="iana:/www/classes/query/personalinfo"></code></p><p>Puedo decir con confianza que, en retrospectiva, me alegro de que haya ganado la solución más genérica.</p><p>El verdadero trabajo en <code>&lt;INPUT\></code> <a href=http://1997.webhistory.org/www.lists/www-talk.1993q1/0079.html>arrancó</a> en enero de 1993 basado en un viejo tipo de SGML. Fue (tal vez desafortunadamente), decidido que las entradas <code>&lt;SELECT\></code> necesitaban una estructura separada, mas rica:</p><pre><code>&lt;select name=FIELDNAME type=CHOICETYPE [value=VALUE] [help=HELPUDI]&gt; 
    &lt;choice&gt;item 1
    &lt;choice&gt;item 2
    &lt;choice&gt;item 3
&lt;/select&gt;
</code></pre><p>Como dato extra, reusar <code>&lt;li></code>, en lugar de introducir <code>&lt;option></code> fue <a href=http://1997.webhistory.org/www.lists/www-talk.1993q2/0188.html>absolutamente</a> considerado. Hubo, por supuesto, propuestas de formas alternativas. <a href=http://1997.webhistory.org/www.lists/www-talk.1993q2/0168.html>Una</a> incluía cierta sustitución de variables evocativa a lo que Angular podría hacer hoy:</p><pre><code>&lt;ENTRYBLANK TYPE=int LENGTH=length DEFAULT=default VAR=lval&gt;Prompt&lt;/ENTRYBLANK&gt;
&lt;QUESTION TYPE=float DEFAULT=default VAR=lval&gt;Prompt&lt;/QUESTION&gt;
&lt;CHOICE DEFAULT=default VAR=lval&gt;
    &lt;ALTERNATIVE VAL=value1&gt;Prompt1 ...
    &lt;ALTERNATIVE VAL=valuen&gt;Promptn
&lt;/CHOICE&gt;
</code></pre><p>En este ejemplo, las entradas son verificadas contra un tipo específico en <code>type</code>, y los valores <code>var</code> están disponibles en la página para ser usados en <a href=http://1997.webhistory.org/www.lists/www-talk.1993q2/0150.html>sustitución de cadenas de texto</a> en URLs, tal como:</p><p><code>http://cloudflare.com/apps/$appId</code></p><p>Propuestas adicionales usaban en realidad <code>@</code>, en lugar de <code>=</code>, para separar componentes de la consulta:</p><p><code>name@value+name@(value&amp;value)</code></p><p>Fue Marc Andreessen quien sugirió el método actual basado en lo que él ya había implementado en Mosaic:</p><p><code>name=value&amp;name=value&amp;name=value</code></p><p>Solo <a href=http://1997.webhistory.org/www.lists/www-talk.1993q4/0437.html>dos meses después</a> Mosaic sumaría soporte para formularios <code>method=POST</code>, y los formularios HTML ‘modernos’ habían nacido.</p><p>Por supuesto, fue también la compañía de Marc Andreessen <a href=https://web.archive.org/web/19990421025406/http://home.mcom.com/newsref/std/cookie_spec.html>Netscape</a> la que crearía el formato de las cookies (usando un separador diferente). Su propuesta fue dolorosamente miope, llevó al intento de introducir el encabezado <a href=https://www.ietf.org/rfc/rfc2965.txt><code>Set-Cookie2</code></a>, e introdujo problemas estructurales con los que lidiamos en Cloudflare al día de hoy.</p><h2 id=fragmentos>Fragmentos</h2><p>La porción de la URL que sigue al ‘#’ es conocida como fragmento. Los fragmentos fueron parte de las URLs desde su <a href=https://www.w3.org/History/19921103-hypertext/hypertext/WWW/Addressing/Addressing.html>especificación inicial</a>, usados para vincular a una ubicación específica en la página que se estaba cargando. Por ejemplo, si tengo un texto ancla en mi sitio:</p><p><code>&lt;a name="bio">&lt;/a></code></p><p>Puedo vincularlo así:</p><p><code>http://zack.is/#bio</code></p><p>Este concepto fue gradualmente extendido a cualquier elemento (en lugar de solo anclas), y movido al atributo <code>id</code> en lugar de <code>name</code>:</p><p><code>&lt;h1 id="bio">Bio&lt;/h1></code></p><p>Tim Berners-Lee decidió usar este carácter basado en su conexión con las direcciones postales de los Estados Unidos (descontando el hecho de que él es Britanico). En <a href=https://www.w3.org/People/Berners-Lee/FAQ.html#etc>sus palabras</a>:</p><blockquote><p>En el correo caracol (correo tradicional) en los Estados Unidos, al menos, es común usar el símbolo cardinal para un número de departamento o número de unidad dentro de un edificio. Así que 12 Acacia Av #12 significa “El edificio en Avenida Acacia 12, y luego dentro de ese edificio la unidad conocida como la número 12”. Parece un carácter natural para la tarea. Ahora, <a href=http://www.example.com/foo#bar>http://www.example.com/foo#bar</a> significa “Dentro del recurso <a href=http://www.example.com/foo>http://www.example.com/foo</a>, la vista conocida como bar”.</p></blockquote><p>Resulta que el <a href=https://en.wikipedia.org/wiki/NLS_%28computer_system%29>sistema original de Hipertexto</a>, creado por Douglas Engelbart, también usaba el carácter ‘#’ para el mismo propósito. Esto puede ser una coincidencia o puede ser un caso accidental de “tomar prestada una idea”.</p><p>Los fragmentos no están explícitamente incluídos en los requerimientos HTTP, lo que significa que solo viven dentro del navegador. Este concepto probó ser muy valioso cuando fue momento de implementar la navegación del lado del cliente (antes de que <a href=https://developer.mozilla.org/en-US/docs/Web/API/History_API>pushState</a> fuera introducido). Los fragmentos fueron también muy valiosos cuando llegó el momento de pensar sobre cómo podemos almacenar estados en las URLs sin enviarlos al servidor. ¿Qué podría significar eso? Explorémoslo:</p><h2 id=granos-de-arena-y-montañas>Granos de arena y Montañas</h2><blockquote><p>Hay todo un estándar, tan asqueroso como el SGML, sobre Electronic data Intercahnge [sic] (intercambio electrónico de datos): formularios y envío de formularios. No sé nada al respecto, excepto que luce como fortran al revés, sin espacios.</p><p>— Tim Berners-Lee, <a href=http://1997.webhistory.org/www.lists/www-talk.1993q1/0091.html>1993</a></p></blockquote><p>Hay una percepción popular de que los cuerpos de estandarización de Internet no hicieron mucho desde la finalización del HTTP 1.1 y el HTML en 4.01 en 2002 hasta el momento en que se empezó a utilizar el HTML 5. Este período es también conocido (solo por mí) como la Edad Oscura del XHTML. La verdad es que la gente de estandarización estaba <em>fantásticamente ocupada</em>. Simplemente estaba ocupada en cosas que finalmente no fueron tan valiosas.</p><p>Uno de esos esfuerzos fue la Web Semántica. El sueño era crear un Resource Description Framework (Estructura de Descripción de Recursos) (nota editorial: corré de cualquier equipo que busca crear un framework), el cual permitiría que los metadatos sobre el contenido fueran universalmente expresados. Por ejemplo, en lugar de crear una linda página web sobre mi Corvette Stingray, crearía un documento RDF describiendo su tamaño, color, y el número de multas por exceso de velocidad que he tenido manejándolo.
Esto, por supuesto, no es una mala idea. Pero el formato era basado en XML, y hubo un gran problema del huevo y la gallina entre tener el mundo entero documentado y hacer que los navegadores hagan algo útil con esa documentación.</p><p>Sí proveyó, sin embargo, un poderoso ambiente para discusiones filosóficas. Una de las mejores discusiones duró al menos diez años, y fue conocida por su increíble nombre <a href=https://www.w3.org/2001/tag/issues.html#httpRange-14>‘httpRange-14’</a>.</p><p>httpRange14 buscaba responder la pregunta fundamental de qué es una URL. ¿Una URL tiene que referir a un documento o puede referir a cualquier cosa? ¿Puedo tener una URL que apunta a mi auto?</p><p>No intentaron responder esa pregunta de ninguna manera satisfactoria. En su lugar hicieron foco en cómo y cuándo podemos usar redirecciones 303 para apuntar usuarios desde vínculos que no son documentos a los que sí lo son, y en cuándo podemos usar fragmentos URL (la parte después del ‘#’) para <a href=http://blog.iandavis.com/2010/11/a-guide-to-publishing-linked-data-without-redirects/>apuntar usuarios a datos vinculados</a>.</p><p>Para la mente pragmática de hoy en día, esto parecería ser una pregunta tonta. Para muchos de nosotros, podés usar una URL para lo que se te ocurra, y la gente usará tu “cosa” o no lo hará. Pero a la Web Semántica le importa solo la semántica, así que se armó.</p><p>Este tema en particular fue discutido el <a href=https://www.w3.org/2002/07/01-tag-summary#arch-doc>1ro de julio de 2002</a>, <a href=https://www.w3.org/2002/07/15-tag-summary#L3330>15 de julio de 2002</a>, <a href=https://www.w3.org/2002/07/22-tag-summary#L3974>22 de julio de 2022</a>, <a href=https://www.w3.org/2002/07/29-tag-summary#httpRange-14>29 de julio de 2002</a>, <a href=https://lists.w3.org/Archives/Public/www-tag/2002Sep/0127>16 de septiembre de 2002</a>, y en al menos otras 20 ocasiones en 2005. Fue resuelto por la gran <a href=https://lists.w3.org/Archives/Public/www-tag/2005Jun/0039.html>resolución httpRange-14</a> de 2005, luego reabierta en <a href=https://lists.w3.org/Archives/Public/www-tag/2007Jul/0034.html>2007</a> y <a href=https://lists.w3.org/Archives/Public/public-awwsw/2011Jan/0021.html>2011</a> y <a href=https://www.w3.org/2001/tag/doc/uddp/change-proposal-call.html>un nuevo llamado para nuevas soluciones</a> en 2012. La pregunta fue duramente discutida por el <a href=https://groups.google.com/forum/#!searchin/pedantic-web/httprange-14/pedantic-web/iLY6VFvN-H0/SXQwc-lOpM8J>pedante grupo</a>, que está muy bien nombrado. Lo único que no pasó fue que todos esos datos semánticos fueran puestos en la web detrás de una URL.</p><h2 id=autenticación>Autenticación</h2><p>Como ya sabrás, podés incluir nombre de usuario y contraseña en las URLs:
<code>http://zack:shhhhhh@zack.is</code></p><p>El navegador luego codifica esos datos de autenticación en <a href=https://en.wikipedia.org/wiki/Base64>Base64</a>, y lo manda como un encabezado:</p><p><code>Authentication: Basic emFjazpzaGhoaGho</code></p><p>La única razón para el codificado en Base64 es para permitir caracteres que pueden no ser válidos en un encabezado, no provee protección a los valores de usuario y contraseña.</p><p>Particularmente en la Internet anterior al SSL, esto era muy problemático. Cualquiera que pudiera pispear tu conexión podía fácilmente ver tu contraseña. <a href=http://1997.webhistory.org/www.lists/www-talk.1993q3/0297.html>Muchas alternativas</a> fueron propuestas incluido <a href=https://en.wikipedia.org/wiki/Kerberos_%28protocol%29>Kerberos</a> que era un protocolo de seguridad muy usado tanto entonces como ahora.</p><p>Como con tantos ejemplos, sin embargo, la <a href=http://1997.webhistory.org/www.lists/www-talk.1993q3/0882.html>propuesta de autenticación básica</a> fue la más fácil de implementar para los desarrolladores de navegadores (Mosaic). Esto la hizo la primera, y en definitiva la única, solución hasta que se le brindaron herramientas a los desarrolladores para crear sus propios sistemas de autenticación.</p><h2 id=la-aplicación-web>La Aplicación Web</h2><p>En el mundo de las aplicaciones web, es un poco raro pensar que la base de la web es el hipervínculo. Es un método para vincular un documento con otro que fue gradualmente mejorado con estilos, ejecución de código, sesiones, autenticación y en última instancia se convirtió en la experiencia social compartida de la informática que tantos investigadores de los 70s estaban tratando (y fallando) de crear. Al final, esa conclusión es válida para cualquier proyecto y startup de hoy o ayer: lo único que importa es la adopción. Si lográs que la gente lo use, sin importar la porquería que sea, te ayudarán a convertirlo en algo que necesitan.</p><p>El corolario es, por supuesto, nadie lo está usando, no importa cuán bueno es técnicamente. Hay incontables herramientas a las cuales fueron millones de horas de trabajo que precisamente nadie usa hoy en día.
*Esto fue adaptado de una publicación que originalmente apareció en el blog Eager. En 2016 Eager se convirtió en <a href=https://www.cloudflare.com/apps>Cloudflare Apps</a>.</p><ul><li>La versión original de este post se puede encontrar en <a href=https://blog.cloudflare.com/the-history-of-the-url/>The Cloudflare Blog</a> (inglés).</li><li>Autoría de <a href=https://blog.cloudflare.com/author/zack-bloom/>Zack Bloom</a>, traducción por <a href=https://twitter.com/jcasarini>@jcasarini</a>, revisión por <a href=https://twitter.com/nachichuri>@nachichuri</a>.</li></ul><div class=ve-desktop><ins class=dcmads style=display:inline-block;width:728px;height:90px data-dcm-placement=N410401.3634809SYSARMY.COMBLOG/B10464038.251052924 data-dcm-rendering-mode=iframe data-dcm-https-only data-dcm-resettable-device-id data-dcm-app-id><script src=https://www.googletagservices.com/dcm/dcmads.js></script></ins></div><div class=ve-mobile><ins class=dcmads style=display:inline-block;width:320px;height:50px data-dcm-placement=N410401.3634809SYSARMY.COMBLOG/B10464038.250920272 data-dcm-rendering-mode=iframe data-dcm-https-only data-dcm-resettable-device-id data-dcm-app-id><script src=https://www.googletagservices.com/dcm/dcmads.js></script></ins></div><script>if(window.innerWidth<960)for(var divsToHide=document.getElementsByClassName("ve-desktop"),i=0;i<divsToHide.length;i++)divsToHide[i].style.visibility="hidden",divsToHide[i].style.display="none";else for(divsToHide=document.getElementsByClassName("ve-mobile"),i=0;i<divsToHide.length;i++)divsToHide[i].style.visibility="hidden",divsToHide[i].style.display="none"</script></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Leer otros posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://sysarmy.com/blog/posts/consejos-junior-devs/><span class=button__icon>←</span>
<span class=button__text>Consejos para desarrolladores junior</span>
</a></span><span class="button next"><a href=https://sysarmy.com/blog/posts/como-finalizar-proyecto/><span class=button__text>¡Cómo terminar un proyecto con todo!</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/blog class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>sysarmy:~ blog$</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://sysarmy.com/blog/assets/main.js></script><script src=https://sysarmy.com/blog/assets/prism.js></script></div></body></html>
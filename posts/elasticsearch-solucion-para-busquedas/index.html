<!doctype html><html lang=en><head><title>Elasticsearch, solución para la busqueda ::
Sysarmy — El blog de quienes dan soporte</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="La versión original de este post se puede encontrar en Medium (inglés).
Un motor de búsqueda y análisis de nivel empresarial Elasticsearch es un motor de búsqueda de texto completo para nuestros propios datos. Indexa y permite buscarlos a través de una interfaz HTTP. Es un motor de búsqueda distribuido basado en Lucene. Puede escalar a petabytes de datos. Admite múltiples usuarios y alta concurrencia. Ofrece resultados de búsqueda casi en tiempo real. Elasticsearch también es un componente de un conjunto de herramientas de código abierto conocido como ELK Stack.
"><meta name=keywords content="sysarmy,elasticsearch,elk,observability,logging"><meta name=robots content="noodp"><link rel=canonical href=https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f><link rel=stylesheet href=https://sysarmy.com/blog/assets/style.css><link rel=stylesheet href=https://sysarmy.com/blog/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://sysarmy.com/blog/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://sysarmy.com/blog/img/favicon.png><link href=https://sysarmy.com/blog/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sysarmy.com/blog/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Elasticsearch, solución para la busqueda"><meta name=twitter:description content="Descubre cómo Elasticsearch permite indexar, buscar y analizar grandes volúmenes de datos en tiempo real, convirtiéndolo en una herramienta esencial para empresas que requieren alta escalabilidad y rendimiento."><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-MW9RRK2")</script><script>function loadScript(e){var n=document.getElementsByTagName("head")[0],t=document.createElement("script");t.type="text/javascript",t.src="https://tracker.metricool.com/resources/be.js",t.onreadystatechange=e,t.onload=e,n.appendChild(t)}loadScript(function(){beTracker.t({hash:"b5c0b4816e829c93645aa7ad738aa3c0"})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4QJX7Y34Y"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4QJX7Y34Y")</script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/blog class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>sysarmy:~ blog$</span>
<span class=logo__cursor></span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://tienda.sysarmy.com/>Tienda</a></li><li><a href=https://www.youtube.com/channel/UCPE3EUzO58EBHzrJp2Fv7_A>Youtube</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://tienda.sysarmy.com/>Tienda</a></li><li><a href=https://www.youtube.com/channel/UCPE3EUzO58EBHzrJp2Fv7_A>Youtube</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Elasticsearch, solución para la busqueda</h1><div class=post-meta><span class=post-date>March 20, 2024
</span><span class=post-read-time>— 15 minutos de lectura aprox.</span></div><span class=post-tags><a href=https://sysarmy.com/blog/tags/sysarmy/>#sysarmy</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/elasticsearch/>#elasticsearch</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/elk/>#elk</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/observability/>#observability</a>&nbsp;
<a href=https://sysarmy.com/blog/tags/logging/>#logging</a>&nbsp;</span><figure class=post-cover><img src=https://sysarmy.com/blog/assets/elasticesarch-cover.png alt="Elasticsearch, solución para la busqueda"></figure><div class=post-content><base href=https://sysarmy.com/blog/><p><em>La versión original de este post se puede encontrar en <a href=https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f>Medium</a> (inglés).</em></p><h3 id=un-motor-de-búsqueda-y-análisis-de-nivel-empresarial>Un motor de búsqueda y análisis de nivel empresarial</h3><p>Elasticsearch es un motor de búsqueda de texto completo para nuestros propios datos. Indexa y permite buscarlos a través de una interfaz HTTP. Es un motor de búsqueda distribuido basado en Lucene. Puede escalar a petabytes de datos. Admite múltiples usuarios y alta concurrencia. Ofrece resultados de búsqueda casi en tiempo real. Elasticsearch también es un componente de un conjunto de herramientas de código abierto conocido como ELK Stack.</p><h2 id=casos-de-uso-de-elasticsearch>Casos de uso de Elasticsearch</h2><ul><li>Log operativo y análisis de logs (ELK)</li><li>Contenido de un sitio y búsqueda de media</li><li>Búsqueda de texto completo</li><li>Datos y métricas de eventos</li><li>Visualización de datos con Kibana</li></ul><h2 id=clúster>Clúster</h2><p><img src=assets/cluster.png alt="Esquema de elastic"></p><p>Un clúster de Elasticsearch es una colección distribuida de nodos en los que cada uno realiza una o más operaciones. Cada nodo ejecuta una instancia de Elasticsearch. El clúster es escalable horizontalmente. Al agregar nodos adicionales al clúster, podemos escalar la capacidad del clúster de manera lineal mientras mantenemos un rendimiento similar. Los nodos se agregan creando y usando un token de enrolamiento.</p><p>Los nodos del clúster se pueden diferenciar según el tipo específico de operaciones que realizan. En los clústeres de alta disponibilidad, designamos diferentes conjuntos de nodos para diferentes funciones del clúster. Para definir roles de nodo, podemos establecer la configuración de esta manera: <code>node.roles: [ master | data | ingest ]</code></p><h2 id=nodo-maestro>Nodo maestro</h2><p>Cada clúster tiene un único nodo maestro en cualquier momento y sus responsabilidades incluyen mantener la salud y el estado del clúster. Los nodos maestros funcionan como coordinadores para crear, eliminar, administrar índices y asignar índices y fragmentos subyacentes a los nodos apropiados del clúster.</p><h2 id=nodo-elegible-maestro>Nodo elegible-maestro</h2><p>Los nodos elegibles para maestros son aquellos candidatos a ser nodos maestros.</p><h2 id=nodo-de-datos>Nodo de datos</h2><p>Los nodos de datos contienen los datos del índice real y manejan la búsqueda y agregación de datos.</p><h2 id=nodo-solo-coordinador>Nodo solo coordinador</h2><p>Estos nodos transmiten solicitudes de consulta a todos los fragmentos relevantes y agregan sus respuestas en un conjunto ordenado globalmente, que se devuelve al cliente. Estos nodos actúan como balanceadores de carga.</p><h2 id=nodo-de-ingesta>Nodo de ingesta</h2><p>Los nodos de ingesta se pueden configurar para preprocesar datos antes de que se ingieran. Como algunos de los procesadores, como el procesador grok, pueden consumir muchos recursos, es beneficioso dedicar nodos separados para la canalización de ingesta, ya que las operaciones de búsqueda no se verán afectadas por el procesamiento de ingesta. De lo contrario, los nodos de datos realizarán esta tarea.</p><p>En grandes clústeres de nubes, tendremos un nodo maestro dedicado, 2 o más nodos de ingesta, 2 o más nodos de coordinación y múltiples nodos de datos.</p><p>Dado que los nodos de datos almacenan los datos, deberían tener discos adjuntos. SSD para datos cálidos y HDD para datos fríos. También necesitamos una gran memoria (RAM) para los nodos de datos, ya que almacenan datos en el buffer.</p><blockquote><p>Elasticsearch está escrito en Java y ejecuta procesos en JVM. Utiliza grupos de subprocesos para diferentes procesos.</p></blockquote><p><code>GET /_cat/thread_pool/search?v&amp;h=host,name,active,rejected,completed</code></p><h2 id=índice>Índice</h2><p>El índice es una colección de tipos similares de documentos. Es una entidad lógica. Físicamente está asignado a fragmentos. El índice está asociado con configuraciones, asignaciones, alias y plantillas.</p><h2 id=alias-de-índice>Alias ​​de índice</h2><p>Un alias es un nombre de índice virtual que puede apuntar a uno o más índices. Esto elimina la necesidad de realizar un seguimiento de qué índice específico consultar, en caso de que los datos estén distribuidos entre índices.</p><p><img src=assets/index-aliases.png alt="Como se compone un indice"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>GET _cat/aliases?v
</span></span><span style=display:flex><span>POST _aliases
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;actions&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;add&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;index&#34;</span>: <span style=color:#e6db74>&#34;index-1&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;alias&#34;</span>: <span style=color:#e6db74>&#34;alias1&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Los alias de índice también ayudan en la migración de índices sin tiempo de inactividad.</p><h2 id=fragmentos>Fragmentos</h2><p>Los índices se dividen horizontalmente en partes llamadas fragmentos . Los fragmentos son un índice de Lucene independiente. Son los componentes básicos del índice.</p><p>Elasticsearch <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html#shard-size-recommendation>recomienda</a> que cada fragmento tenga menos de 65 GB (AWS <a href=https://docs.aws.amazon.com/opensearch-service/latest/developerguide/sizing-domains.html>recomienda</a> que tengan menos de 50 GB), por lo que podríamos crear índices basados ​​en el tiempo en los que cada índice contenga entre 16 y 20 GB de datos, lo que proporciona algo de espacio para el crecimiento de los datos.</p><blockquote><p>Fragmentos primarios y de replicación</p></blockquote><p>Para obtener los fragmentos de un índice <code>GET _cat/shards/index</code></p><p>Ciclo de vida del fragmento: Inicializando → Iniciado → Reubicación → No asignado</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;settings&#34;</span> : <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;index&#34;</span> : <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;number_of_shards&#34;</span> : 8,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;number_of_replicas&#34;</span> : <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=translogbúfer-de-memoria>Translog/búfer de memoria</h2><p>Las confirmaciones de Lucene son demasiado costosas para realizar en cada cambio individual, por lo que cada copia de fragmento también escribe operaciones en su registro de transacciones conocido como translog. Cada fragmento tiene un translog. Los datos del translog solo se conservan en un disco con la confirmación de Lucene. En caso de error, esto se repite para confirmar los cambios no guardados. Durante una confirmación, todos los segmentos en la memoria se fusionan en un solo segmento y se guardan en el disco.</p><p><img src=assets/elasticsearch-persis-model.png alt="Modelo de persistencia"></p><p><img src=assets/elasticsearch-persis-model-2.png alt="Ciclo de vida de un documento"></p><blockquote><p>Actualización (refresh): el contenido del búfer de memoria se copia en un segmento recién creado en la memoria y se borra el translog. Sucede cada segundo.</p></blockquote><blockquote><p>Tirado (flush): los segmentos en memoria se escriben en el disco. Los segmentos más pequeños se fusionan en segmentos más grandes.</p></blockquote><h2 id=segmentos>Segmentos</h2><p>El índice de Lucene se divide en archivos más pequeños llamados segmentos. Los segmentos son un índice invertido y son inmutables. Lucene busca en todos los segmentos de forma secuencial. Por lo tanto, tener muchos segmentos puede afectar el rendimiento. Elasticsearch fusiona los segmentos para crear nuevos segmentos eliminando documentos eliminados. La fusión también ayuda a combinar segmentos más pequeños en segmentos más grandes, ya que los segmentos más pequeños tienen un rendimiento de búsqueda deficiente.</p><h2 id=documentos>Documentos</h2><p>Un documento es una unidad de información que se pasa a Elasticsearch para su almacenamiento. Los documentos son archivos JSON que se almacenan dentro de un índice de Elasticsearch y se consideran la unidad base de almacenamiento. Los documentos son inmutables. En caso de una actualización, el archivo anterior se reemplaza por el nuevo. El campo _version en la respuesta del documento es cosa del pasado y ya no tiene significado.</p><h2 id=campos>Campos</h2><p><em>tipos de datos como binario, booleano, palabra clave, números, fechas, texto, geo_shape, search_as_you_type</em></p><h2 id=metacampos>Metacampos</h2><blockquote><p>_index: nombre del índice</p><p>_type</p><p>_id: identificación única del documento</p><p>_source: documento JSON original antes de aplicar cualquier analizador/transformación.</p><p>_all : contiene todos los demás campos de su documento</p></blockquote><p>Mapeo indicativo del objeto ES con la base de datos:</p><blockquote><p>MySQL => Bases de datos => Tablas => Fila => Columna => Índice</p><p>Elasticsearch => Índices => Tipos => Documentos => Propiedades => Mapeo</p></blockquote><h2 id=estructuras-de-datos-internas-utilizadas-por-es>Estructuras de datos internas utilizadas por ES</h2><blockquote><p>Índice invertido: para datos de texto</p><p>Árbol BKD: datos numéricos, de fecha y geoespaciales</p><p>doc_values: clasificación y agregaciones</p></blockquote><h2 id=analizadores>Analizadores</h2><p>Elasticsearch proporciona analizadores que definen cómo se debe indexar y buscar el texto. Los analizadores se utilizan durante la indexación para analizar frases y expresiones en sus términos constitutivos. Definido dentro de un índice, un analizador consta de un único tokenizador y cualquier número de filtros de tokens.</p><p><img src=assets/analyzers.png alt=Analizadores></p><p>El analizador tiene tres componentes:</p><ul><li>Filtros de caracteres <code>(html_strip)</code></li><li>Tokenizador <code>(standard)</code></li><li>Filtro de tokens <code>(lowercase)</code></li></ul><p>Elasticsearch tiene muchos analizadores, tokenizadores y filtros de tokens integrados.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>POST /_analyze
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;text&#34;</span> : <span style=color:#e6db74>&#34;Este texto será analizado con el analizador ESTÁNDAR&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;analyzer&#34;</span> : <span style=color:#e6db74>&#34;standard&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>POST /_analyze
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;text&#34;</span> : <span style=color:#e6db74>&#34;Este texto será analizado con el analizador ESTÁNDAR&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;char_filter&#34;</span> : <span style=color:#f92672>[]</span> ,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;tokenizer&#34;</span> : <span style=color:#e6db74>&#34;standard&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;filter&#34;</span> : <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;lowercase&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=plantilla-de-índice>Plantilla de índice</h2><p>Una plantilla de índice es un esqueleto mediante el cual se crea un nuevo índice.</p><h2 id=gestión-del-ciclo-de-vida-del-índice>Gestión del ciclo de vida del índice</h2><p>Cada índice pasa por diferentes fases (caliente → tibio → frío → eliminado). Según una configuración predefinida, ILM modelará los índices de una fase a otra.</p><p><img src=assets/index-lifecycle.png alt="ciclo de un indice"></p><h2 id=canalización-de-ingesta>Canalización de ingesta</h2><p>Los canales de ingesta nos permiten aplicar transformaciones como eliminación de campos , extracción de información o incluso enriquecimiento de datos antes de indexar un documento. Una canalización consta de varias tareas configurables conocidas como procesadores . Elasticsearch almacena las canalizaciones como una estructura de datos interna en el estado del clúster.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>GET _nodes/ingest?filter_path<span style=color:#f92672>=</span>nodes.*.ingest.processors
</span></span><span style=display:flex><span>PUT _ingest/pipeline/blog-demo-pipeline
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;version&#34;</span>: 1,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;Canalización de demostración para blog mediano&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;processors&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;set&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;Establecer valor predeterminado de etiqueta&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;field&#34;</span>: <span style=color:#e6db74>&#34;StoryTag&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;value&#34;</span>: <span style=color:#e6db74>&#34;Ingeniería de datos&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;lowercase&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;field&#34;</span>: <span style=color:#e6db74>&#34;author&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;remove&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;field&#34;</span>: <span style=color:#e6db74>&#34;external_reads&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>POST _ingest/pipeline/blog-demo-pipeline/_simulate
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;docs&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>...<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>POST users/_doc?pipeline<span style=color:#f92672>=</span>blog-demo-pipeline
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>...<span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>POST _reindex
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;source&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;index&#34;</span>: <span style=color:#e6db74>&#34;nombre de índice existente&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;dest&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;index&#34;</span>: <span style=color:#e6db74>&#34;nuevo nombre de índice&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;op_type&#34;</span>: <span style=color:#e6db74>&#34;create&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;pipeline&#34;</span>: <span style=color:#e6db74>&#34;blog-demo-pipeline&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=replicación-de-datos>Replicación de datos</h2><p><img src=assets/data-replication.png alt="Replicacion de datos"></p><p>Elasticsearch tiene conceptos de <strong>fragmento primario</strong> y <strong>fragmento de réplica</strong>.</p><p>El proceso de replicar datos del fragmento primario al fragmento de réplica se llama <strong>replicación de datos</strong>. La consideración principal de la replicación de datos es el retraso ( <strong>lag</strong> ) de la réplica y el primario. Si Lag es siempre 0, entonces se trata de una replicación en tiempo real con la mayor confiabilidad. Elasticsearch implementa la replicación de datos con la ayuda de la <strong>replicación de documentos</strong> y la <strong>replicación de segmentos</strong>.</p><h2 id=indexación-de-documentos>Indexación de documentos</h2><p>Los datos de entrada a Elasticsearch se analizan y tokenizan antes de almacenarlos. Normalmente, la biblioteca de Lucene solo almacena los tokens analizados. Elasticsearch también almacena el documento original tal como se recibió en un campo especial llamado <code>_source</code>. Aunque consume espacio de almacenamiento adicional, el campo <code>_source</code> es fundamental para proporcionar la funcionalidad de actualización de documentos y también es necesario para las operaciones de reindexación.</p><h2 id=enrutamiento-de-documentos>Enrutamiento de documentos</h2><p>Elasticsearch utiliza un algoritmo de enrutamiento para distribuir nuestros documentos a los fragmentos subyacentes durante la indexación. Cada uno de los documentos se indexará en un solo fragmento primario. Los documentos están distribuidos uniformemente, por lo que no hay posibilidad de que uno de los fragmentos se sobrecargue.</p><p>El algoritmo de enrutamiento es una fórmula simple en la que Elasticsearch deduce el fragmento de un documento durante la indexación o la búsqueda:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>shard <span style=color:#f92672>=</span> hash <span style=color:#f92672>(</span> id <span style=color:#f92672>)</span> % número_de_fragmentos
</span></span></code></pre></div><p>La función hash espera una identificación única, generalmente una identificación de documento o incluso una identificación personalizada proporcionada por el usuario.</p><p><em>Nota: Los documentos no se recuperan del fragmento principal, pero ES aprovecha la Selección de réplica adaptable (ARS) para seleccionar un fragmento del grupo de replicación.</em></p><h2 id=el-flujo-de-solicitudes-de-índice-en-es>El flujo de solicitudes de índice en ES</h2><ol><li>La solicitud es recibida por un nodo coordinador.</li><li>El nodo enruta documentos a sus índices y fragmentos.</li><li>Los fragmentos primarios y de réplica escriben (en paralelo) los documentos en translog.</li><li>Los documentos se normalizan (mapeo y análisis) y se almacenan en un búfer en memoria.</li><li>Los índices se actualizan para que se puedan realizar búsquedas.</li><li>Lucene confirma nuevos segmentos en los discos.</li></ol><h2 id=búsqueda-de-documentos>Búsqueda de documentos</h2><blockquote><p><strong>Fase de consulta</strong>: el nodo coordinador enruta la solicitud a todos los fragmentos del índice. Los fragmentos, de forma independiente, realizan búsquedas y crean una cola de prioridad de los resultados ordenados por puntuación de relevancia. Todos los fragmentos devuelven los ID de los documentos coincidentes y las puntuaciones relevantes al nodo coordinador. El nodo coordinador crea una nueva cola de prioridad y ordena los resultados globalmente. El nodo coordinador crea una cola de prioridad que ordena los resultados de todos los fragmentos y devuelve los 10 resultados principales.</p><p><strong>Fase de recuperación</strong>: los nodos coordinadores solicitan los documentos originales de los fragmentos. Los fragmentos enriquecen los documentos y los devuelven al nodo coordinador.</p><p><strong>Guardado de documentos</strong>: frecuencia de plazo (TF), frecuencia inversa de documento (IDF), norma. relevance_score = TF * IDF. Podemos adjuntar un indices_boost objeto al mismo nivel que el objeto de consulta. Esto aumentará la precedencia del índice impulsado. Ahora ES utiliza el algoritmo Okapi BM25 para calcular la relevancia.</p></blockquote><p>Existen varios tipos de predicados de consultas de búsqueda:</p><blockquote><p><em>Term, Terms</em></p><p><em>ids</em></p><p><em>exists</em></p><p><em>range</em></p><p><em>wildcard</em></p><p><em>Prefix</em></p><p><em>regexp</em></p><p><em>match_phrasse, multi_match, match_all</em></p><p><em>fuzzy</em></p><p><em>synonyms</em></p></blockquote><h2 id=filtro-vs-contexto-de-consulta>Filtro vs contexto de consulta</h2><p>El contexto del filtro proporciona una respuesta Sí/No en la coincidencia con la consulta proporcionada. Los filtros se almacenan en caché de forma predeterminada y no contribuyen a la puntuación de relevancia del documento. Sin embargo, el contexto de consulta muestra qué tan bien coincide cada documento con la consulta. Hace uso de analizadores para tomar una decisión. Los resultados incluyen una puntuación de relevancia.</p><p>A menos que sea una búsqueda de texto completo o un tipo de búsqueda de puntuación de relevancia, se recomienda la búsqueda de contexto de filtro. Los filtros son generalmente más rápidos en comparación con las consultas.</p><h2 id=enfoques-de-paginación>Enfoques de paginación</h2><ul><li><strong>from / size</strong>: el parámetro <code>from</code> define la cantidad de elementos que queremos omitir desde el principio. El parámetro <code>size</code> es el número máximo de visitas que se devolverán.</li><li><strong>API _scroll</strong>: se utiliza para recuperar una gran cantidad de resultados. Se parece a los cursores de las bases de datos SQL. No recomendado para solicitudes de usuarios. Debe usarse en modo por lotes.</li><li><strong>buscar_después</strong></li><li><strong>Punto en el tiempo (PIT)</strong></li></ul><h2 id=agregación>Agregación</h2><blockquote><p><em>Agregación de métricas: suma, mín., máx., promedio.</em></p><p><em>Agregados de métricas numéricas/no numéricas.</em></p><p><em>Agregados de depósitos: ordena los resultados de la consulta en un grupo.</em></p><p><em>Agregados de canalización: canaliza el agregado de una etapa a otra.</em></p></blockquote><h2 id=flujo-de-datos>Flujo de datos</h2><p>Los flujos de datos simplifican el manejo de datos de series temporales. Maneja alias de índice de sustitución e índices, y define asignaciones y configuraciones comunes para los índices de respaldo. Aprovecha las políticas de Index Statement Management (ISM).</p><h2 id=configuraciones>Configuraciones</h2><blockquote><p><em>flush_threshold_size</em></p><p><em>index_buffer_size</em></p><p><em>refresh_interval</em></p><p><em>threadpool.bulk.queue_size</em></p></blockquote><h2 id=instalación-en-k8s>Instalación en K8s</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm repo add bitnami https://charts.bitnami.com/bitnami
</span></span><span style=display:flex><span><span style=color:#75715e># helm repo add elastic https://helm.elastic.co</span>
</span></span><span style=display:flex><span>helm install elasticsearch --set master.replicas<span style=color:#f92672>=</span>3,coordinating.service.type<span style=color:#f92672>=</span>LoadBalancer bitnami/elasticsearch
</span></span><span style=display:flex><span>kubectl port-forward svc/elasticsearch-master <span style=color:#ae81ff>9200</span>
</span></span><span style=display:flex><span>curl localhost:9200
</span></span></code></pre></div><p><em>Nota: ES utiliza 9200 para API y búsqueda, y 9300 para comunicación entre nodos.</em></p><h2 id=operadores-de-k8>Operadores de K8</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Elastic</span>
</span></span><span style=display:flex><span>kubectl create -f https://download.elastic.co/downloads/eck/2.5.0/crds.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://download.elastic.co/downloads/eck/2.5.0/operator.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># opensearch</span>
</span></span><span style=display:flex><span>helm repo add opensearch-operator https://opster.github.io/opensearch-k8s-operator/
</span></span><span style=display:flex><span>helm install opensearch-operator opensearch-operator/opensearch-operator
</span></span></code></pre></div><h2 id=trabajando-con-python>Trabajando con Python</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># pip install elasticsearch</span>
</span></span><span style=display:flex><span><span style=color:#75715e># pip install opensearch-py</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> elasticsearch <span style=color:#f92672>import</span> Elasticsearch
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> elasticsearch <span style=color:#f92672>import</span> helpers
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>    pd<span style=color:#f92672>.</span>read_csv(<span style=color:#e6db74>&#34;wiki_movie_plots_deduped.csv&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>dropna()
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>sample(<span style=color:#ae81ff>5000</span>, random_state<span style=color:#f92672>=</span><span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>reset_index()
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http://root:root@localhost:9200&#39;</span>
</span></span><span style=display:flex><span>es <span style=color:#f92672>=</span> Elasticsearch(url)
</span></span><span style=display:flex><span><span style=color:#75715e># es = Elasticsearch([{&#39;host&#39;: &#39;localhost&#39;, &#39;port&#39;: 9200}])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mappings <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;properties&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;title&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;english&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;ethnicity&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;standard&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;director&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;standard&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;cast&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;standard&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;genre&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;standard&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;plot&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;text&#34;</span>, <span style=color:#e6db74>&#34;analyzer&#34;</span>: <span style=color:#e6db74>&#34;english&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;year&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;integer&#34;</span>},
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;wiki_page&#34;</span>: {<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;keyword&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>index_name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;movies&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>index_exists <span style=color:#f92672>=</span> es<span style=color:#f92672>.</span>indices<span style=color:#f92672>.</span>exists(index <span style=color:#f92672>=</span> index_name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> index_exists:
</span></span><span style=display:flex><span>  es<span style=color:#f92672>.</span>indices<span style=color:#f92672>.</span>create(index <span style=color:#f92672>=</span> index_name, mappings <span style=color:#f92672>=</span> mapping, ignore<span style=color:#f92672>=</span><span style=color:#ae81ff>400</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># curl -XGET [http://localhost:9200/retail_store]</span>
</span></span><span style=display:flex><span>docs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i, row <span style=color:#f92672>in</span> df<span style=color:#f92672>.</span>iterrows():
</span></span><span style=display:flex><span>    doc <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;title&#34;</span>: row[<span style=color:#e6db74>&#34;Title&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ethnicity&#34;</span>: row[<span style=color:#e6db74>&#34;Origin/Ethnicity&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;director&#34;</span>: row[<span style=color:#e6db74>&#34;Director&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;cast&#34;</span>: row[<span style=color:#e6db74>&#34;Cast&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;genre&#34;</span>: row[<span style=color:#e6db74>&#34;Genre&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;plot&#34;</span>: row[<span style=color:#e6db74>&#34;Plot&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;year&#34;</span>: row[<span style=color:#e6db74>&#34;Release Year&#34;</span>],
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;wiki_page&#34;</span>: row[<span style=color:#e6db74>&#34;Wiki Page&#34;</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    docs<span style=color:#f92672>.</span>append(doc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>helpers<span style=color:#f92672>.</span>bulk(es, docs, index<span style=color:#f92672>=</span>index_name, doc_type<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;_doc&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>query <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;query&#34;</span> : {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bool&#34;</span> : {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;must&#34;</span> : {
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#34;match_phrase&#34;</span> : {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;cast&#34;</span> : <span style=color:#e6db74>&#34;jack nicholson&#34;</span>,
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;filter&#34;</span>: {<span style=color:#e6db74>&#34;bool&#34;</span>: {<span style=color:#e6db74>&#34;must_not&#34;</span>: {<span style=color:#e6db74>&#34;match_phrase&#34;</span>: {<span style=color:#e6db74>&#34;director&#34;</span>: <span style=color:#e6db74>&#34;roman polanski&#34;</span>}}}},
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>results <span style=color:#f92672>=</span> es<span style=color:#f92672>.</span>search(index<span style=color:#f92672>=</span>index_name, body<span style=color:#f92672>=</span>query, size <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># get all hits</span>
</span></span><span style=display:flex><span><span style=color:#75715e># helpers.scan(client=es, query=query, index=index_name)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>es<span style=color:#f92672>.</span>delete(index <span style=color:#f92672>=</span> index_name, id <span style=color:#f92672>=</span> doc_id)
</span></span><span style=display:flex><span><span style=color:#75715e># es.delete_by_query(index = index_name, query = query)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>es<span style=color:#f92672>.</span>indices<span style=color:#f92672>.</span>put_settings(index<span style=color:#f92672>=</span>index_name, body<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;value&#34;</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>es<span style=color:#f92672>.</span>indices<span style=color:#f92672>.</span>delete(index<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;movies&#39;</span>)
</span></span></code></pre></div><p>La <strong>configuración</strong> incluye propiedades específicas del índice, como la cantidad de fragmentos, analizadores, etc. El <strong>mapeo</strong> se utiliza para definir cómo se supone que se almacenan e indexan los documentos y sus campos. Definimos los tipos de datos para cada campo o utilizamos mapeo dinámico para campos desconocidos.</p><p><em>Nota: Para las API masivas, mientras trabaja con cURL utilice el header <code>Content-Type: application/x-ndjson</code></em></p><h2 id=indexación-por-niveles>Indexación por niveles</h2><p>Elasticsearch nos permite tener diferentes niveles y, por tanto, diferentes perfiles de hardware para los nodos de datos. Lo hacemos estableciendo el atributo <code>node.role</code> en el archivo <code>elasticsearch.yml</code> de configuración.</p><blockquote><p><em>Caliente — data_hot</em></p><p><em>Tibio — data_warm</em></p><p><em>Frío — data_cold</em></p><p><em>Congelado — data_frozen</em></p></blockquote><p><img src=assets/tiered-indexing.png alt="organizacion de los indices"></p><h2 id=api-básicas>API básicas</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>POST &lt;index-name&gt;/_search?explain<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>GET &lt;index1&gt;,&lt;index2&gt;,&lt;index3&gt;/_search
</span></span><span style=display:flex><span>GET /_cluster/health
</span></span><span style=display:flex><span>GET /_cat/indices?h<span style=color:#f92672>=</span>index
</span></span><span style=display:flex><span>GET index/_settings
</span></span><span style=display:flex><span>GET index/_mapping
</span></span><span style=display:flex><span>DELETE /document-index/_doc/id
</span></span><span style=display:flex><span>POST document-index/_delete_by_query?conflicts<span style=color:#f92672>=</span>proceed
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;query&#34;</span>: <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;match_all&#34;</span>: <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>GET /_analyze
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;analyzer&#34;</span> : <span style=color:#e6db74>&#34;standard&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;text&#34;</span> : <span style=color:#e6db74>&#34;Hello, from Elastic Search.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=interactuando-con-spark>Interactuando con Spark</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># via package</span>
</span></span><span style=display:flex><span><span style=color:#f92672>--</span>packages org<span style=color:#f92672>.</span>elasticsearch:elasticsearch<span style=color:#f92672>-</span>hadoop:<span style=color:#ae81ff>7.10.1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># or via pip</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>!</span>pip install elasticsearch<span style=color:#f92672>-</span>hadoop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df <span style=color:#f92672>=</span> spark<span style=color:#f92672>.</span>read
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>format(<span style=color:#e6db74>&#34;org.elasticsearch.spark.sql&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>option(<span style=color:#e6db74>&#34;es.nodes&#34;</span>,<span style=color:#e6db74>&#34;http://host:9200&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>option(<span style=color:#e6db74>&#34;es.read.metadata&#34;</span>, <span style=color:#e6db74>&#34;true&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>option(<span style=color:#e6db74>&#34;es.read.field.include&#34;</span>, <span style=color:#e6db74>&#34;text,user&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#34;index/type&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>df<span style=color:#f92672>.</span>write
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>format(<span style=color:#e6db74>&#34;org.elasticsearch.spark.sql&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>option(<span style=color:#e6db74>&#34;es.nodes&#34;</span>,<span style=color:#e6db74>&#34;http://localhost:9200&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>option(<span style=color:#e6db74>&#34;es.write.operation&#34;</span>, <span style=color:#e6db74>&#34;upsert&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>.</span>save(<span style=color:#e6db74>&#34;index/type&#34;</span>)
</span></span></code></pre></div><h2 id=herramientas-de-administración-de-elasticsearch>Herramientas de administración de Elasticsearch</h2><p><a href=https://github.com/lmenezes/cerebro>Cerebro</a></p><h2 id=personalización-de-elasticsearch-con-complementos-plugins>Personalización de Elasticsearch con complementos (plugins)</h2><p>Elasticsearch tiene una arquitectura de complemento que permite ampliar y personalizar la funcionalidad. Los complementos son generalmente archivos de artefactos empaquetados (jar, zip, rpm) que se guardan en una ubicación específica. Podemos utilizar la herramienta de línea de comandos <code>elasticsearch-plugin</code> para instalar, enumerar y eliminar complementos. Algunas categorías de complementos comunes son:</p><blockquote><p><em>Complemento de extensión API</em></p><p><em>Complemento de snapshots</em></p><p><em>Complemento de discovery</em></p><p><em>Complemento de mapeo</em></p><p><em>Complemento de integración</em></p></blockquote><p><code>GET _cat/complements</code></p><h2 id=empresas-que-utilizan-elasticsearch>Empresas que utilizan Elasticsearch</h2><blockquote><p>Swiggy, Quora, AutoDesk, Adobe, Walmart, Grab, Tinder, Uber, Visa, Compass, Pearson, Pinterest, Wikimedia, Netflix</p></blockquote><h2 id=cuellos-de-botella>Cuellos de botella</h2><ul><li><strong>Administrador de clústeres</strong>: a medida que el número de nodos supera los 300, el sistema se vuelve lento y el reinicio del clúster se vuelve lento.</li><li><strong>Asignador de fragmentos</strong></li><li>Sin <strong>controlador de admisión para consultas incorrectas</strong>: sin prevención proactiva para consultas incorrectas</li><li>El <strong>costo de almacenamiento</strong> se vuelve alto para una mayor retención de datos</li><li><strong>Acoplamiento directo entre complemento y núcleo</strong>, sin segmentación de recursos</li><li>Elasticsearch no permite la instalación en múltiples centros de datos.</li></ul><h2 id=oferta-de-nube-en-aws>Oferta de nube en AWS</h2><p>AWS ofrece el servicio OpenSearch, que es un fork de Elasticsearch. Hay dos ofertas en este servicio: administrado y serverless. La oferta de AWS tiene las siguientes ventajas:</p><blockquote><p><em>Alertas de seguridad mejoradas</em></p><p><em>Analizador de rendimiento</em></p><p><em>Compatibilidad con consultas SQL</em></p><p><em>Gestión de índices</em></p><p><em>Búsqueda de vecino k-más cercano</em></p></blockquote><h2 id=trabajos-futuros-en-proceso-para-opensearch>Trabajos futuros en proceso para OpenSearch</h2><ul><li>Almacenamiento remoto</li><li>Almacenamiento en caché inteligente</li><li>Replicación cruzada y completa del clúster</li></ul><h2 id=resumen>Resumen</h2><p>En pocas palabras, la indexación de ES se puede resumir en los siguientes pasos</p><ul><li>Envío de datos a API</li><li>Los datos se enrutan al índice, al nodo y al fragmento</li><li>Mapeo, normalización y análisis</li><li>Persistencia al disco</li><li>Datos disponibles para buscar</li></ul><p>Gracias por leer!!</p><ul><li>La versión original de este post se puede encontrar en <a href=https://blog.devgenius.io/elasticsearch-solution-to-searching-71116220c82f>Medium</a> (inglés).</li><li>Autoría por <a href=https://asrathore08.medium.com/>Amit Singh Rathore</a>, traducción por <a href=https://github.com/vmariano>@vmariano</a>, revisión por <a href=https://twitter.com/nachichuri>@nachichuri</a>.</li></ul><div class=ve-desktop><ins class=dcmads style=display:inline-block;width:728px;height:90px data-dcm-placement=N410401.3634809SYSARMY.COMBLOG/B10464038.251052924 data-dcm-rendering-mode=iframe data-dcm-https-only data-dcm-resettable-device-id data-dcm-app-id><script src=https://www.googletagservices.com/dcm/dcmads.js></script></ins></div><div class=ve-mobile><ins class=dcmads style=display:inline-block;width:320px;height:50px data-dcm-placement=N410401.3634809SYSARMY.COMBLOG/B10464038.250920272 data-dcm-rendering-mode=iframe data-dcm-https-only data-dcm-resettable-device-id data-dcm-app-id><script src=https://www.googletagservices.com/dcm/dcmads.js></script></ins></div><script>if(window.innerWidth<960)for(var divsToHide=document.getElementsByClassName("ve-desktop"),i=0;i<divsToHide.length;i++)divsToHide[i].style.visibility="hidden",divsToHide[i].style.display="none";else for(divsToHide=document.getElementsByClassName("ve-mobile"),i=0;i<divsToHide.length;i++)divsToHide[i].style.visibility="hidden",divsToHide[i].style.display="none"</script></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Leer otros posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://sysarmy.com/blog/posts/primeros-60-dias-laborales/><span class=button__icon>←</span>
<span class=button__text>Tus primeros 60 días trabajando en sistemas</span>
</a></span><span class="button next"><a href=https://sysarmy.com/blog/posts/por-que-c-es-relevante-en-el-2024/><span class=button__text>¿Por qué el lenguaje de programación C es relevante en el 2024? ... Y lo seguirá siendo.</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><a href=/blog class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>sysarmy:~ blog$</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2025 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://sysarmy.com/blog/assets/main.js></script><script src=https://sysarmy.com/blog/assets/prism.js></script></div></body></html>